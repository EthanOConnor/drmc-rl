diff --git a/envs/retro/placement_wrapper.py b/envs/retro/placement_wrapper.py
--- a/envs/retro/placement_wrapper.py
+++ b/envs/retro/placement_wrapper.py
@@ -1,9 +1,11 @@
 class DrMarioPlacementEnv(gym.Wrapper):
-    """Wrapper exposing the 464-way placement action space."""
+    """Wrapper exposing the 464-way placement action space (spawn-latched)."""
 
     def __init__(self, env: gym.Env, *, planner: Optional[PlacementPlanner] = None) -> None:
         super().__init__(env)
         self.action_space = gym.spaces.Discrete(action_count())
         self._translator = PlacementTranslator(env, planner)
         self._last_obs: Any = None
         self._last_info: Dict[str, Any] = {}
         self._active_plan: Optional[PlanResult] = None
         self._latched_action: Optional[int] = None
         self._latched_spawn_id: int = -1
         self._spawn_id: int = 0
         self._capsule_present: bool = False
+        # Translator-provided marker; used only to detect spawn changes.
+        self._spawn_marker: Optional[int] = None
@@
     def reset(self, **kwargs):
         obs, info = self.env.reset(**kwargs)
         self._last_obs = obs
         if info is None:
             info = {}
         self._translator.refresh()
         self._active_plan = None
         self._latched_action = None
         self._latched_spawn_id = -1
         self._capsule_present = False
         self._spawn_id = 0
+        self._spawn_marker = None
         obs, info, _, _, _ = self._await_next_pill(obs, info)
         self._last_obs = obs
         self._last_info = info
         self._capsule_present = bool(self._translator.current_pill() is not None)
-        self._spawn_id = max(0, int(info.get("placements/spawn_id", 0)))
+        # keep our _spawn_id monotonic & internal; do not overwrite from info
         return obs, info
@@
     def step(self, action: int):
+        # Always resync at step start (fixes “one inference per run”).
+        self._translator.refresh()
+
+        # Allow a deliberate override to clear latch inside the same spawn.
+        if (
+            self._active_plan is not None
+            and self._latched_spawn_id == self._spawn_id
+            and self._latched_action is not None
+            and int(action) != self._latched_action
+        ):
+            self._clear_latch()
+
         total_reward = 0.0
         terminated = False
         truncated = False
         last_obs = self._last_obs
         last_info: Dict[str, Any] = {}
         replan_attempts = 0
         planner_calls = 0
         planner_latency_ms_total = 0.0
         planner_latency_ms_max = 0.0
         planner_plan_count_total = 0.0
         planner_plan_count_last = 0.0
         planner_latency_ms_last = 0.0
 
         def record_refresh_metrics() -> None:
             nonlocal planner_calls, planner_latency_ms_total, planner_latency_ms_max
             nonlocal planner_plan_count_total, planner_plan_count_last, planner_latency_ms_last
-            diagnostics = self._translator.diagnostics()
-            latency = float(diagnostics.get("plan_latency_ms", 0.0))
-            plan_count = float(diagnostics.get("plan_count", 0.0))
-            planner_calls += 1
-            planner_latency_ms_total += latency
-            planner_latency_ms_max = max(planner_latency_ms_max, latency)
-            planner_plan_count_total += plan_count
-            planner_plan_count_last = plan_count
-            planner_latency_ms_last = latency
+            diagnostics = self._translator.diagnostics() or {}
+            latency = float(diagnostics.get("plan_latency_ms", 0.0) or 0.0)
+            plan_count = float(diagnostics.get("plan_count", 0.0) or 0.0)
+            if plan_count == 0.0 and latency == 0.0:
+                return
+            planner_calls += 1
+            planner_latency_ms_total += latency
+            planner_latency_ms_max = max(planner_latency_ms_max, latency)
+            planner_plan_count_total += plan_count
+            planner_plan_count_last = plan_count
+            planner_latency_ms_last = latency
+
+        # Helpers
+        def _read_spawn_marker() -> Optional[int]:
+            snap = self._translator.current_pill()
+            if snap is None:
+                return None
+            info_t = self._translator.info() or {}
+            marker = info_t.get("placements/spawn_id", getattr(snap, "spawn_id", None))
+            try:
+                return int(marker) if marker is not None else None
+            except Exception:
+                return None
+
+        def _mark_needs_action(base: Optional[Dict[str, Any]]) -> Dict[str, Any]:
+            out = dict(base or {})
+            out["placements/needs_action"] = True
+            out["placements/spawn_id"] = int(self._spawn_id)
+            out.setdefault("pill_changed", 0)
+            return out
@@
-        if self._translator.current_pill() is None:
+        if self._translator.current_pill() is None:
             obs, info, reward_delta, terminated, truncated = self._await_next_pill(
                 self._last_obs, self._last_info, record_refresh_metrics
             )
             total_reward += reward_delta
             last_obs = obs
             last_info = info
             self._last_obs = last_obs
             self._last_info = last_info
             self._active_plan = None
             self._latched_action = None
             self._latched_spawn_id = -1
             return last_obs, total_reward, terminated, truncated, last_info
@@
-        def request_new_decision(base_info: Optional[Dict[str, Any]]) -> Dict[str, Any]:
-            info_payload = dict(base_info or {})
-            info_payload["placements/needs_action"] = True
-            info_payload["placements/spawn_id"] = int(self._spawn_id)
-            info_payload["pill_changed"] = 0
+        def request_new_decision(base_info: Optional[Dict[str, Any]]) -> Dict[str, Any]:
+            info_payload = _mark_needs_action(base_info)
             for key in (
                 "placements/legal_mask",
                 "placements/feasible_mask",
                 "placements/options",
                 "placements/costs",
                 "placements/path_indices",
             ):
-                if key in info_payload:
-                    info_payload.pop(key)
+                info_payload.pop(key, None)
             return info_payload
@@
             outcome = self._execute_plan(plan, record_refresh_metrics)
             total_reward += outcome.reward
             last_obs = outcome.last_obs
             last_info = outcome.info
             terminated = outcome.terminated
             truncated = outcome.truncated
+            # RAM advanced; resync after running a micro-schedule.
+            self._translator.refresh()
+            record_refresh_metrics()
 
             if terminated or truncated:
                 self._clear_latch()
                 break
             if outcome.replan_required:
-                replan_attempts += 1
-                last_info = request_new_decision(last_info)
+                # record failed placement & re-request a decision
+                li = dict(last_info or {})
+                li["placements/feasible_fp"] = int(li.get("placements/feasible_fp", 0)) + 1
+                failed_idx = self._latched_action if self._latched_action is not None else int(action)
+                li["placements/failed_action_idx"] = int(failed_idx)
+                last_info = request_new_decision(li)
+                replan_attempts += 1
                 self._clear_latch()
                 break
-            pill_rolled = bool(last_info.get("pill_changed", False))
-            capsule_missing = self._translator.current_pill() is None
-            if pill_rolled or capsule_missing:
-                self._clear_latch()
-                break
-            # Continue executing the same plan; ignore the external action while latched.
-            continue
+
+            # Detect next spawn during/after plan execution
+            pill_now = self._translator.current_pill() is not None
+            marker_now = _read_spawn_marker() if pill_now else None
+            new_spawn = (
+                pill_now
+                and marker_now is not None
+                and self._spawn_marker is not None
+                and marker_now != self._spawn_marker
+            )
+            if new_spawn:
+                self._spawn_marker = marker_now
+                self._spawn_id += 1
+                self._capsule_present = True
+                info_now = _mark_needs_action(self._translator.info())
+                info_now["pill_changed"] = 1
+                last_info = {**last_info, **info_now}
+                self._clear_latch()
+                break
+
+            # Normal case: plan progressed; finish this env step.
+            self._capsule_present = pill_now
+            break
@@
         self._last_info = enriched_info
-        if "placements/needs_action" not in enriched_info:
-            enriched_info["placements/needs_action"] = False
-            enriched_info.setdefault("placements/spawn_id", int(self._spawn_id))
+        # Do not force a decision spam; only on spawn/replan.
+        if "placements/needs_action" not in enriched_info:
+            enriched_info["placements/needs_action"] = False
+        enriched_info.setdefault("placements/spawn_id", int(self._spawn_id))
         return last_obs, total_reward, terminated, truncated, enriched_info
@@
     def _await_next_pill(
         self,
         last_obs: Any,
         last_info: Dict[str, Any],
         record_refresh: Optional[Callable[[], None]] = None,
     ) -> Tuple[Any, Dict[str, Any], float, bool, bool]:
         """Advance the emulator until a new pill snapshot becomes available."""
@@
-        if self._translator.current_pill() is not None:
-            if not self._capsule_present:
-                self._spawn_id += 1
-            self._capsule_present = True
-            info.update(self._translator.info())
-            info["placements/spawn_id"] = int(self._spawn_id)
-            info["placements/needs_action"] = True
-            return obs, info, total_reward, terminated, truncated
+        if self._translator.current_pill() is not None:
+            if not self._capsule_present:
+                self._spawn_id += 1
+            self._capsule_present = True
+            # capture translator marker now
+            try:
+                tinfo = self._translator.info() or {}
+                self._spawn_marker = int(tinfo.get("placements/spawn_id", getattr(self._translator.current_pill(), "spawn_id", None)))
+            except Exception:
+                self._spawn_marker = None
+            info.update(self._translator.info() or {})
+            info["placements/spawn_id"] = int(self._spawn_id)
+            info["placements/needs_action"] = True
+            info.setdefault("pill_changed", 1)
+            return obs, info, total_reward, terminated, truncated
@@
             if self._translator.current_pill() is not None:
-                info = dict(info)
-                info.update(self._translator.info())
-                if not self._capsule_present:
-                    self._spawn_id += 1
-                self._capsule_present = True
-                info["placements/spawn_id"] = int(self._spawn_id)
-                info["placements/needs_action"] = True
-                break
+                info = dict(info)
+                info.update(self._translator.info() or {})
+                if not self._capsule_present:
+                    self._spawn_id += 1
+                self._capsule_present = True
+                try:
+                    tinfo = self._translator.info() or {}
+                    self._spawn_marker = int(tinfo.get("placements/spawn_id", getattr(self._translator.current_pill(), "spawn_id", None)))
+                except Exception:
+                    self._spawn_marker = None
+                info["placements/spawn_id"] = int(self._spawn_id)
+                info["placements/needs_action"] = True
+                info.setdefault("pill_changed", 1)
+                break