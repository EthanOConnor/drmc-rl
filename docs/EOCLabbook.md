* EOC Notes during DRMC_rl development *

19 Oct 2025

Two thoughts for drmc_rl - add another layer of intent, implementing "specify row, column, and orientation" for pill placement; translator maintains internal game state and model of board evolution and will emit properly timed controls to the emulator to achieve the desired placement with closed loop observation of state and response; this should dramatically tighten the learning curve for RL agents, as they can focus on high-level strategy rather than low-level control timing. The action space is an outcome space rather than a path space and is orders of magnitude smaller. We could even have the translator emit a legal placements (or even a possible placements based on translator internal game model) mask to further constrain the action space.

THEN, we suddenly have a way to dramatically reduce inference compute demand. We no longer have to update the policy input/output for every emulator step. The translator simply notifies the system when a new decision is needed (i.e. at pill spawn, or if the original game model was wrong). This could reduce the number of inferences by a factor of 10-20x, depending on how fast the pills are falling. This opens the door to running on much more constrained hardware, or running multiple agents in parallel on the same hardware.

In fact, the change to asynchronous (or temporally sparser) decision making can be applied independently of the placement intent layer. Even if our intents are directions instead of placements, there's now a window where the translator can handle the low-level control until the next decision point. This could still yield significant compute savings, though not as dramatic as with placement intents. Depending on the game dynamics (gravity, etc), this could still be a 2-5x reduction in inference frequency.

*** Roadmap from here ***
Even more than a fast / strong Dr Mario speedrunner / speed bracketer / eventual vs bracketer, I'm interested in doing

25 Oct 2025
Next up to implement - we are still working on getting the planner called at the right time and for the action taker to do horizontal moves correctly, but in the mean time we have a plan to dramatically (100x +) speed up the reachability/cost/planner/microplanner: Close - the stacked grids are the orientation of the pill! I realized we can unify the feasibility pass and the path planner - drop the 1x1 approximation for feasibility but don't think about trying to rotate a 2x1 through gaps in occupied squares on a 2D lattice.- that seems complicated for the microrouting. Instead model the pill configuration in a set of 4 planes, one for each possible orientation - {0_1, 0|1, 1_0, 1|0} of the pill. Then in each of the grids the occupied spaces are slightly different - reflecting if you can pill half 0 at that spot at that orientation. So actually grid 1 and 3 and grid 2 and 4 have the same occupancies marked. Then feasibility with orientation accounted for becomes the same flood fill process as we were originally thinking about for the 2D lattice with separate route / microroute planning. Then if we maintain a parent log we can just map the steps in reverse to actions and voila we have a lowest cost reachibility/feasibility map and a microrouter in the full configuration/placement space. We don't even have to worry about different structure at the edges / blocking for example moving from vertical to horizontal 1_0 when on the left boundary - the 1_0 grid just has the whole left edge marked as occupied et voila.

**** RNG and Pill Sequence Logging ****
Remembered that I had questions about the RNG on the pill sequences. Multiple chat agents have insisted to me that the RNG has color symmetry but I'm pretty, pretty sure it doesn't - red blitzes sure feel like a thing, along with long streaks with no blues. And even in the virus layout - I know that I have a distinct preference for certain pills to show up at the initial layout - ironically a bit reversed from the actual needs - but that it is roughly:

1) Any double color pill - but especially red-red or yellow-yellow
2) Red-Yellow
3) Red-Blue
4) Yellow-Blue

Our existing infrastructure should be plenty to log pill sequences, but we do still need a player good enough to make it deep into pill sequences. In fact - we should train two different styles of players - one that is optimized for speedrunning (fast placements, less concern for efficiency), and one that is optimized for long-term survival (more careful placements, more concern for efficiency). If we are interested in deep-level pill sequence logging, the survival-optimized player is needed.

But initially, let's start trying to build up an efficiently stored library of the pill sequences we see. Would like to determine a couple things right away to inform this logging and search: Does the rng randomization (and lack thereof) in speedrun_experiment.py apply to the pill sequence and the placement equally? Anyway - either way, there's almost certainly a dterministic mapping from certain initial states to certain pill sequences, and we can log indexed on that and not double-log sequences we've seen before (like our default startup seed in the non-randomized configuration).

Other questions to investigate:
  1) Are sequence characteristics the same across levels, speeds, pill depths?
  2) Are they affected by input stream during play?
  3) Several levels of measurements - overall color distribution, run lengths of each color, frequency of double-color pills, frequency of each color pair, frequency of certain triplets or quadruplets (e.g. RYB, RRB, RYY, etc). Imbalance in spawn parity. for ngrams, we can do a tiered sorted histogram with bars colored by pill color (we can use a trie structure to store counts efficiently?) - showing both uniformity of distribution and some structure as well. Different hierarchies. For simple color availability, top level is RBY counts, next level is RR, RY, RB, YY, YB, BB counts, next level is RRR, RRY, RRB, RYY, RYB, RBB, YYY, YYB, YBB, BBB counts, etc. Then we have actual pill distribution, so top level is RR, RY, RB, YY, YB, BB counts, next is RR-RR, RR-RY, RR-RB, etc., then RR-RR-RR, RR-RR-RY, etc. Doing sorted histograms lets us see quite a bit of information even on the huge lists we encounter at higher depths. (We can also compute entropy measures at each level to quantify randomness vs structure.?)
  4) How long a sequence do we need to observe to predict the upcoming pills precisely? Are there patterns at a less specified level that can be exploited? (e.g. "after a red-red, a yellow is more likely than a blue"?, "after a long streak of no blues, a blue is more likely"?)

**** Cheat Detection ****
Once we have a database of pill sequences and can recover the seed from a fixed length of observation, we can review people's speedrun and live tournament streams to see if they are using cheat tools to manipulate the RNG to get better/known pill sequences. More likely, we suppose is having a database of known fast/easy board layouts. If you had a layout evaluator or a database of plays across layouts w/ distributions of finishing times across sequences, you could have several hundred known fast layouts that you circulate through or just slip in every once in a while.

**** Annotation and Stats for Training ****
Having built a libretro training environment for our Dr Mario player with full RAM access and state extraction, do we have the ability to do instrumentation (like level time tracking & virus elimination speed stats, pill colors, eventually "par" time for starting layout (based either on catalog or value network, depending on size of starting layout possibility space) / predicted time to finish from here for you) for live players playing in an emulator (presumably retroarch)? But focused first on just being a super reliable & accurate level split / PR / progress tracker that runs within an emulator. Later we'll tie in to the pixel/vision input path as well and this will become the live stream overlay!
